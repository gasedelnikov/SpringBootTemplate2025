CREATE OR REPLACE FUNCTION ${defaultSchema}.audit() RETURNS TRIGGER AS
$audit$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        NEW.created_ts := now();
        NEW.updated_ts := current_timestamp;
    ELSIF (TG_OP = 'UPDATE') THEN
        NEW.updated_ts := current_timestamp;
    END IF;
    RETURN NEW;
END;
$audit$ LANGUAGE plpgsql;

CREATE TYPE ${defaultSchema}.USER_STATUS_ENUM AS ENUM ('created', 'registered', 'deleted');

CREATE TABLE ${defaultSchema}.usr
(
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    login           VARCHAR(50)                             NOT NULL,
    description     TEXT                                    NULL,
    status          ${defaultSchema}.USER_STATUS_ENUM       NOT NULL,
    password        VARCHAR(60)                             NOT NULL,
    created_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    created_user_id BIGINT                                  NULL,
    updated_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    updated_user_id BIGINT                                  NULL,

    CONSTRAINT user_pk PRIMARY KEY (id),
    CONSTRAINT user_login_uq UNIQUE (login),
    CONSTRAINT user_non_empty_login_chk CHECK (login <> '')
);
COMMENT ON TABLE ${defaultSchema}.usr IS 'Пользователи';
CREATE TRIGGER audit
    BEFORE INSERT OR UPDATE
    ON ${defaultSchema}.usr
    FOR EACH ROW
EXECUTE PROCEDURE ${defaultSchema}.audit();


CREATE TYPE ${defaultSchema}.AUTHOR_TYPE_ENUM AS ENUM ('a1', 'a2', 'b1', 'b2');

CREATE TABLE ${defaultSchema}.author
(
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    type            ${defaultSchema}.AUTHOR_TYPE_ENUM       NOT NULL,
    fio             TEXT                                    NOT NULL,
    description     TEXT                                    NULL,

    created_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    created_user_id BIGINT                                  NOT NULL,
    updated_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    updated_user_id BIGINT                                  NOT NULL,

    CONSTRAINT author_pk PRIMARY KEY (id),
    CONSTRAINT author_2_user_created_fk FOREIGN KEY (created_user_id) REFERENCES ${defaultSchema}.usr (id),
    CONSTRAINT author_2_user_updated_fk FOREIGN KEY (updated_user_id) REFERENCES ${defaultSchema}.usr (id)

);
COMMENT ON TABLE ${defaultSchema}.author IS 'Авторы';
CREATE TRIGGER audit
    BEFORE INSERT OR UPDATE
    ON ${defaultSchema}.author
    FOR EACH ROW
EXECUTE PROCEDURE ${defaultSchema}.audit();


CREATE TABLE ${defaultSchema}.book
(
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    author_id       BIGINT                                  NOT NULL,
    name            VARCHAR(255)                            NOT NULL,
    description     TEXT                                    NULL,
    info            JSONB                                   NULL,

    created_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    created_user_id BIGINT                                  NOT NULL,
    updated_ts      TIMESTAMPTZ                             NOT NULL DEFAULT NOW(),
    updated_user_id BIGINT                                  NOT NULL,

    CONSTRAINT book_pk PRIMARY KEY (id),
    CONSTRAINT book_author_name_uq UNIQUE (author_id, name),

    CONSTRAINT book_2_user_created_fk FOREIGN KEY (created_user_id) REFERENCES ${defaultSchema}.usr (id),
    CONSTRAINT book_2_user_updated_fk FOREIGN KEY (updated_user_id) REFERENCES ${defaultSchema}.usr (id),
    CONSTRAINT book_2_author_fk FOREIGN KEY (author_id) REFERENCES ${defaultSchema}.author (id)
);
COMMENT ON TABLE ${defaultSchema}.book IS 'Книги';
COMMENT ON COLUMN ${defaultSchema}.book.name IS 'name';
CREATE TRIGGER audit
    BEFORE INSERT OR UPDATE
    ON ${defaultSchema}.book
    FOR EACH ROW
EXECUTE PROCEDURE ${defaultSchema}.audit();

